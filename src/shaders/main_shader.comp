#version 450

layout (local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0) uniform InputBuffer1 {
    mat4 lookDir;

    vec4 initPos;
    vec4 initDir;

	float xPosMultiplier;
	float yPosMultiplier;
	
    float xDirMultiplier;
	float yDirMultiplier;

    float sampleAmount;

} camera_info;


layout(set = 0, binding = 1) uniform InputBuffer2 {
    // Sunce
    float sun_distance;
    float sun_radius;
    float sun_angle;

    // Planet
    float planet_radius;

    // Atmosfera
    float atmosphere_surface_pressure_pa;
	float atmosphere_average_distance;
	float atmosphere_upper_limit;

    float atmosphere_temperature;
	float atmosphere_molar_mass;

	float atmosphere_refractivity;
    float atmosphere_atom_radius;

    // Dodatno
    double K;

} atmosphere_info;

layout(set = 0, binding = 2, rgba8) uniform image2D outputPixels;





void main(){

    // dohvati globalni ID jedinice - jedna jedinica se izvodi po pikselu slike
    uint gIDx = gl_GlobalInvocationID.x; // Odgovara x i y koordinatama slike
    uint gIDy = gl_GlobalInvocationID.y;
    uint gID = gIDx + gIDy * imageSize(outputPixels).x;

    // Raèunanje pozicije i smjera zrake na temelju pozicije kamere i njezinoj širini pogleda (izraženom kao faktor nagiba)
    vec3 initPos  = mat3(camera_info.lookDir) * vec3((float(gIDx) - imageSize(outputPixels).x/2.0)*camera_info.xPosMultiplier, (float(gIDy) - imageSize(outputPixels).y/2.0)*camera_info.yPosMultiplier, 0.0) + camera_info.initPos.xyz;
    vec3 velocity =                             vec3((float(gIDx) - imageSize(outputPixels).x/2.0)*camera_info.xDirMultiplier, (float(gIDy) - imageSize(outputPixels).y/2.0)*camera_info.yDirMultiplier, 0.0) + camera_info.initDir.xyz;

    // Rotacija zrake zajedno s kamerom
    velocity = mat3(camera_info.lookDir) * velocity;
    

    // Rani završetak ako je zraka u planetu

    // Centar planeta je središte koordinatnog sustava, tj. 0,0,0
    vec4 floor_color = vec4(0.7,0.7,0.7,0);
    if (length(initPos) < atmosphere_info.planet_radius){ // Zraka je u planetu
        imageStore(outputPixels, ivec2(gIDx, gIDy), floor_color);
        return;
    }

    bool intersecting_planet = false;
    float planet_t_min = 0; // Toèke u kojima zraka presijeca planet;
    float planet_t_max = 0; 


    // Ukoliko se zraka približava planetu, presjek je moguæ
    float planet_vector_dot = dot(normalize(vec3(-initPos)),normalize(velocity)); // Skalarni umnožak vektora piksela i poèetnog vektora pozicije zrake do planeta u radijanima
    if (planet_vector_dot <= 0){ // Kut im je manji od 90

        // Rješavanje jednadžbe presjeka pravca s kuglom
        float a = 1;
        float b = 2 * dot(normalize(velocity), vec3(initPos));
        float c = dot(vec3(initPos),vec3(initPos)) - atmosphere_info.planet_radius*atmosphere_info.planet_radius;
    
        // Determinanta
        float d = b*b - 4*a*c;

        if (d >= 0){ // Pravac ima presjek s planetom, buduæi da se zraka giba prema planetu presjek je na usmjerenom dijelu
            intersecting_planet = true;
        } 

        float tmp_1 = (-b) / (2*a);
        float tmp_2 = sqrt(b*b - 4*a*c) / (2*a);

        float t1 = -(tmp_1 + tmp_2);
        float t2 = -(tmp_1 - tmp_2);
                
        planet_t_min = min(t1,t2); // Toèke manje od 0 nalaze se iza poèetne pozicije zrake
        planet_t_max = max(t1,t2); 
    }
    

    float sun_light = 0;
    if (intersecting_planet){
        // Èisto reprezentativan izraèun difuznog osvijetljenja površine planeta - linearno se skalira ovisno o sunèevom kutu (i radi samo pod pretpostavkom da je planet velik i približno ispod kamere)
        
        if (atmosphere_info.sun_angle <= 180) {
            float tmp = atmosphere_info.sun_angle / 180.0; // [0.0 - 180.0] -> [0.0 - 1.0]
            tmp -= 0.5;          // -> [-0.5 - 0.5]
            tmp = -abs(tmp);     // -> [-0.5 - 0 - -0.5]
            tmp += 0.5;          // -> [0 - 0.5 - 0]
            sun_light = tmp * 2; // -> [0 - 1 - 0]
        }

        imageStore(outputPixels, ivec2(gIDx, gIDy), floor_color * sun_light);
        return;
    }
    {

        // Provjera udara li zraka sunce

        bool looking_at_sun = false;

        // Sunce æe uvijek biti na xy ravnini
        vec3 sun_pos = vec3(cos(radians(atmosphere_info.sun_angle)), sin(radians(atmosphere_info.sun_angle)),0) * atmosphere_info.sun_distance;
        
        // Rješavanje jednadžbe presjeka pravca s kuglom - skoro jednaka kao za planet
        vec3 Qpos = vec3(initPos) - vec3(sun_pos);
        float a = 1;
        float b = 2 * dot(normalize(velocity), Qpos);
        float c = dot(Qpos,Qpos) - atmosphere_info.sun_radius*atmosphere_info.sun_radius;
    
        // Determinanta
        float d = b*b - 4*a*c;

        float sun_vector_dot = dot(normalize(vec3(sun_pos-initPos)),normalize(velocity));
        
        if (d >= 0 && sun_vector_dot <= 0 && !intersecting_planet){ // Gledamo direktno u sunce
            looking_at_sun = true;
        } 


        {
            
            // Provjera presjeka s atmosferom planeta
            
            // Još jedna jednadžba kugle
            float a = 1;
            float b = 2 * dot(normalize(velocity), vec3(initPos));
            float atmosphere_radius = atmosphere_info.planet_radius + atmosphere_info.atmosphere_upper_limit;
            float c = dot(vec3(initPos),vec3(initPos)) - (atmosphere_radius)*(atmosphere_radius);
            // Determinanta
            float d = b*b - 4*a*c;

            if (d > 0){ // Postoji presjek i dogaða se u više od 1 toèke
                // Raèunanje rješenja

                float tmp_1 = (-b) / (2*a);
                float tmp_2 = sqrt(b*b - 4*a*c) / (2*a);

                float t1 = -(tmp_1 + tmp_2);
                float t2 = -(tmp_1 - tmp_2);
                
                float t_max = max(t1,t2); // Toèke manje od 0 nalaze se iza poèetne pozicije zrake
                float t_min = min(t1,t2);

                if (t1 < 0 && t2 < 0){ // Oba presjecišta su iza smjera vektora, zraka ne sijeèe atmosferu
                    if (looking_at_sun){
                        imageStore(outputPixels, ivec2(gIDx, gIDy), vec4(1,1,1,0));
                    }
                    else{
                        imageStore(outputPixels, ivec2(gIDx, gIDy), vec4(0,0,0,0));
                    }
                    return;
                }

                if (t_min < 0) t_min = 0; // Ako je prva toèka iza poèetka zrake stavi je na poèetak

                if (intersecting_planet && t_max > planet_t_min) t_max = planet_t_min; // Ako zraka prolazi kroz planet ogranièi uzorke na atmosferu prije ulaska

                vec4 output_color = vec4(0,0,0,0);
                //if (intersecting_planet) output_color = floor_color * sun_light * camera_info.sampleAmount;
                
                
                vec3 red_wave_color   = vec3(1.0,0.0,0.0);
                vec3 green_wave_color = vec3(0.0,1.0,0.0);
                vec3 blue_wave_color  = vec3(0.0,0.0,1.0);

                
                // Poèetna (upadna) zraka sunca

                vec3 starting_ray_light = vec3(10,10,10);

                // Ukupno svjetlo koje kamera dobiva
                vec3 total_light = vec3(0,0,0);
              
                float pi = 3.141592654;

                float red_wavelenght   = 630 * 0.000000001; // nanometri
	            float green_wavelenght = 525 * 0.000000001;
	            float blue_wavelenght  = 440 * 0.000000001;
                

                // Uzimanje toèaka uzorka
                for(int i = 1; i < camera_info.sampleAmount; i++){
                    
                    // Ukupno svjetlo koje ova zraka pridonosi
                    vec3 total_ray_light = vec3(0,0,0);

                    // Pozicija toèke uzorka na liniji
                    float t_smpl = (t_min * (1-(float(i)/(camera_info.sampleAmount-1))) + t_max * (float(i)/(camera_info.sampleAmount-1))); // Interpolacija
                    
                    // Pozicija toèke uzorka u prostoru
                    vec3 t_pos = initPos - normalize(velocity) * t_smpl;

                    float distance_from_center = length(t_pos);

                    float distance_from_surface = distance_from_center - atmosphere_info.planet_radius;

                   
                    // Vektor od toèke prema suncu
                    vec3 ray_sun_vector = sun_pos - t_pos;
                   
                    // Provjera presjeka s planetom
            
                    // Još jedna jednadžba kugle
                    float a = 1;
                    float b = 2 * dot(normalize(ray_sun_vector), vec3(t_pos));
                    float c = dot(vec3(t_pos),vec3(t_pos)) - (atmosphere_info.planet_radius)*(atmosphere_info.planet_radius);
                    // Determinanta
                    float d = b*b - 4*a*c;

                    bool hit_surface = false;

                    if (d >= 0){ // Postoji presjek
                        float tmp_1 = (-b) / (2*a);
                        float tmp_2 = sqrt(b*b - 4*a*c) / (2*a);

                        float t1 = -(tmp_1 + tmp_2);
                        float t2 = -(tmp_1 - tmp_2);
                
                        float t_max_tmp = max(t1,t2); // Toèke manje od 0 nalaze se iza poèetne pozicije zrake
                        float t_min_tmp = min(t1,t2);

                        if (t_max_tmp <= 0){ // Veæe presjecište je ispred zrake
                            hit_surface = true;
                        }
                    }

                    // Kolièina svjetla koje doðe do toèke gledanja
                    vec3 in_scatter_light = vec3(0,0,0);
                    if (looking_at_sun) in_scatter_light = starting_ray_light;

                    if (!hit_surface){ 

                        // In-scattering - koliko svjetlosti se dobije raspršivanjem sunèevih zraka
                        {
                            // Traži se presjek zrake s atmosferom
                    
                            // Finalna jednadžba kugle pls
                            float a = 1;
                            float b = 2 * dot(normalize(ray_sun_vector), vec3(t_pos));
                            float c = dot(vec3(t_pos),vec3(t_pos)) - (atmosphere_radius)*(atmosphere_radius);
                            // Determinanta
                            float d = b*b - 4*a*c;
                            if (d > 0){ // Jedini put kada ovo ne bi trebalo vrijediti je na samom rubu atmosfere u nekim rijetkim sluèajevima
                                // Raèunanje rješenja

                                float tmp_1 = (-b) / (2*a);
                                float tmp_2 = sqrt(b*b - 4*a*c) / (2*a);

                                float t1 = -(tmp_1 + tmp_2);
                                float t2 = -(tmp_1 - tmp_2);

                                // Bitan je samo t_max ovdje
                                float t_max_2 = max(t1,t2); // Toèke manje od 0 nalaze se iza poèetne pozicije zrake
                                float t_min_2 = min(t1,t2);

                                vec3 ray_light = starting_ray_light;

                                // Zraka svjetlosti se gubi od sunca do zrake gledanja

                                // Drugi set uzroènih toèaka - sada na zraci prema suncu
                                // Odreðuje se srednja gustoæa zraka na putu

                                float average_density_ratio = 0;

                                for(int j = 0; j < camera_info.sampleAmount; j++){
                                    // Pozicija toèke uzorka na liniji
                                    float t_smpl_2 = (0 * (1-(float(j)/(camera_info.sampleAmount-1))) + t_max_2 * (float(j)/(camera_info.sampleAmount-1))); // Interpolacija
                    
                                    // Pozicija druge toèke uzorka u prostoru
                                    vec3 t_pos_2 = t_pos + normalize(ray_sun_vector) * t_smpl_2;

                                    float distance_from_center_2 = length(t_pos_2);
                                    float distance_from_surface_2 = distance_from_center_2 - atmosphere_info.planet_radius;
                                    
                                    average_density_ratio += exp(-distance_from_surface_2/atmosphere_info.atmosphere_average_distance) * t_max_2/camera_info.sampleAmount;
                                }
                                    
                                //average_density_ratio /= (camera_info.sampleAmount);

                                // funkcija t u onoj jednadžbi
                                float rayleigh_part_1_red   = 4 * pi * average_density_ratio * (float(atmosphere_info.K) / (red_wavelenght   * red_wavelenght   * red_wavelenght   * red_wavelenght   ));
                                float rayleigh_part_1_green = 4 * pi * average_density_ratio * (float(atmosphere_info.K) / (green_wavelenght * green_wavelenght * green_wavelenght * green_wavelenght ));
                                float rayleigh_part_1_blue  = 4 * pi * average_density_ratio * (float(atmosphere_info.K) / (blue_wavelenght  * blue_wavelenght  * blue_wavelenght  * blue_wavelenght  ));

                                
                                // Množenje s kutom
                                float sun_angle = acos(dot(normalize(ray_sun_vector), normalize(velocity)));

                                float angle_const = 3.0/(4.0) * (1 + cos(sun_angle) * cos(sun_angle));

                                float rayleigh_part_2_red   = ray_light.r  * angle_const * average_density_ratio * (float(atmosphere_info.K) / (red_wavelenght   * red_wavelenght   * red_wavelenght   * red_wavelenght   )) * exp(-rayleigh_part_1_red);
                                float rayleigh_part_2_green = ray_light.g  * angle_const * average_density_ratio * (float(atmosphere_info.K) / (green_wavelenght * green_wavelenght * green_wavelenght * green_wavelenght )) * exp(-rayleigh_part_1_green);
                                float rayleigh_part_2_blue  = ray_light.b  * angle_const * average_density_ratio * (float(atmosphere_info.K) / (blue_wavelenght  * blue_wavelenght  * blue_wavelenght  * blue_wavelenght  )) * exp(-rayleigh_part_1_blue);
                                
                                in_scatter_light += vec3(rayleigh_part_2_red, rayleigh_part_2_green, rayleigh_part_2_blue);
                                
                            }
                        }
                     
                    }
                        
                    

                  
                    //vec3 total_ray_light_2 = vec3(1,1,1);
                    
                    //vec3 scatter_multiplier = vec3(1,1,1);

                    // Out-scattering - koliko svjetlosti se izgubi raspršivanjem pri putovanju prema kameri
                    {
                        float average_density_ratio_2 = 0;

                        for(int j = 0; j < camera_info.sampleAmount; j++){
                            // Pozicija toèke uzorka na liniji
                            float t_smpl_2 = (t_min * (1-(float(j)/(camera_info.sampleAmount-1))) + t_max * (float(j)/(camera_info.sampleAmount-1))); // Interpolacija
                            // Pozicija druge toèke uzorka u prostoru
                            vec3 t_pos_2 = initPos + normalize(ray_sun_vector) * t_smpl_2;
                            float distance_from_center_2 = length(t_pos_2);
                            float distance_from_surface_2 = distance_from_center_2 - atmosphere_info.planet_radius;
                            average_density_ratio_2 += exp(-distance_from_surface_2/atmosphere_info.atmosphere_average_distance) * (t_max-t_min)/camera_info.sampleAmount;
                        }

                        //average_density_ratio_2 /= (camera_info.sampleAmount);

                        float rayleigh_part_1_red   = 4 * pi * average_density_ratio_2 * (float(atmosphere_info.K) / (red_wavelenght   * red_wavelenght   * red_wavelenght   * red_wavelenght   ));
                        float rayleigh_part_1_green = 4 * pi * average_density_ratio_2 * (float(atmosphere_info.K) / (green_wavelenght * green_wavelenght * green_wavelenght * green_wavelenght ));
                        float rayleigh_part_1_blue  = 4 * pi * average_density_ratio_2 * (float(atmosphere_info.K) / (blue_wavelenght  * blue_wavelenght  * blue_wavelenght  * blue_wavelenght  ));

                        total_ray_light.r = in_scatter_light.r * exp(-rayleigh_part_1_red  );
                        total_ray_light.g = in_scatter_light.g * exp(-rayleigh_part_1_green);
                        total_ray_light.b = in_scatter_light.b * exp(-rayleigh_part_1_blue );
                                
                        // total_ray_light je Ipv, total_light je Iv
                        total_light += total_ray_light;
                    }
                    
                }
                
                //total_light /= (camera_info.sampleAmount);
                total_light = total_light.r * red_wave_color + total_light.g * green_wave_color + total_light.b * blue_wave_color;

                output_color = vec4(total_light,1);

                vec4 output_color_formatted = vec4(output_color.b, output_color.g, output_color.r, 0); 
                imageStore(outputPixels, ivec2(gIDx, gIDy), output_color_formatted); 
                return;
            }
            else{
                if (looking_at_sun){
                    imageStore(outputPixels, ivec2(gIDx, gIDy), vec4(1,1,1,0));
                }
                else{
                    imageStore(outputPixels, ivec2(gIDx, gIDy), vec4(0,0,0,0));
                }
                
                return;
            }

            
            return;
        }

       
    }

	

	
}